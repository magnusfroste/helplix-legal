import { useCallback, useEffect, useMemo, useState } from 'react';
import type { CooperSettings, ConversationStatus, AnalysisDepth } from '@/types/helplix';
import { useRealtimeVoice } from './useRealtimeVoice';
import { useCooperChat } from './useCooperChat';
import { usePhaseTracking } from './usePhaseTracking';
import { useLogEntries } from './useLogEntries';
import { useFeatureFlags } from './useFeatureFlags';
import { useJurisdictionPrompts } from './useJurisdictionPrompts';
import { toast } from 'sonner';

interface UseConversationOptions {
  settings: CooperSettings;
  userId?: string;
}

export function useConversation({ settings, userId }: UseConversationOptions) {
  // Feature flags
  const { getFlag } = useFeatureFlags();
  const { getPromptForCountry, getIntensityForCountry } = useJurisdictionPrompts();
  const useRealtimeSTT = getFlag('realtime_transcription');
  const useStreamingTTS = getFlag('streaming_tts');
  
  // Analysis depth state - user's choice for this session
  const [analysisDepth, setAnalysisDepth] = useState<AnalysisDepth | null>(null);
  
  // Get system prompt and intensity from database based on country
  const systemPrompt = useMemo(() => {
    if (settings.country) {
      return getPromptForCountry(settings.country);
    }
    return '';
  }, [settings.country, getPromptForCountry]);

  // Calculate question intensity based on baseline + analysis depth modifier
  const questionIntensity = useMemo(() => {
    const baseline = settings.country ? getIntensityForCountry(settings.country) : 70;
    
    if (!analysisDepth) return baseline;
    
    switch (analysisDepth) {
      case 'quick':
        return Math.max(0, baseline - 40);
      case 'standard':
        return baseline;
      case 'thorough':
        return Math.min(100, baseline + 30);
      default:
        return baseline;
    }
  }, [settings.country, getIntensityForCountry, analysisDepth]);
  
  // State for realtime transcript display
  const [realtimeTranscriptText, setRealtimeTranscriptText] = useState('');

  // Log entries and session management
  const logEntries = useLogEntries({
    settings,
    userId,
    onError: (error) => toast.error(error),
  });

  // Phase and quality tracking
  const phaseTracking = usePhaseTracking();

  // Voice service - with realtime STT and streaming TTS support
  const voice = useRealtimeVoice({
    useRealtimeSTT,
    useStreamingTTS,
    onRealtimeTranscript: (text) => setRealtimeTranscriptText(text),
  });

  // Chat service - use jurisdiction prompt and intensity from database
  const chat = useCooperChat({
    settings,
    systemPrompt, // Pass the jurisdiction-specific prompt
    questionIntensity, // Pass the jurisdiction-specific intensity
    currentPhase: phaseTracking.currentPhase,
    informationGaps: phaseTracking.informationGaps,
    completeness: phaseTracking.completeness,
    onError: (error) => toast.error(error),
  });

  // Derived status - memoized to prevent recalculation
  const status: ConversationStatus = useMemo(() => {
    if (voice.isRecording) return 'listening';
    if (voice.isTranscribing) return 'processing';
    if (chat.isLoading) return 'thinking';
    if (voice.isSpeaking) return 'speaking';
    return 'idle';
  }, [voice.isRecording, voice.isTranscribing, chat.isLoading, voice.isSpeaking]);

  const isBusy = useMemo(() => status !== 'idle', [status]);

  // Sync language to session
  useEffect(() => {
    if (chat.userLanguage) {
      logEntries.updateSessionLanguage(chat.userLanguage);
    }
  }, [chat.userLanguage, logEntries.updateSessionLanguage]);

  // Core action: process user response
  const processResponse = useCallback(async (text: string) => {
    console.log('processResponse called with:', { 
      text, 
      userId, 
      currentSessionId: logEntries.currentSessionId, 
      phase: phaseTracking.currentPhase 
    });
    
    // Save to log entries
    const { savedQuestion, savedAnswer } = await logEntries.addQuestionAndAnswer(
      logEntries.currentQuestion,
      text
    );

    if (!savedQuestion || !savedAnswer) {
      return; // Failed to save, error already shown
    }

    // Process through phase tracking to get follow-up decisions
    const { shouldFollowUp, followUpQuestion, nextPhase } = phaseTracking.processUserResponse(
      text,
      logEntries.currentQuestion
    );

    try {
      let nextQuestion: string;
      
      if (shouldFollowUp && followUpQuestion) {
        // Use the follow-up question generated by quality control
        nextQuestion = followUpQuestion;
      } else {
        // Get next question from AI
        nextQuestion = await chat.sendMessage(text, nextPhase);
      }
      
      logEntries.updateCurrentQuestion(nextQuestion);

      if (settings.autoplaySpeech && settings.ttsEnabled) {
        voice.speak(nextQuestion).catch(console.error);
      }
    } catch (error) {
      console.error('AI response error:', error);
    }
  }, [userId, logEntries, phaseTracking, settings.autoplaySpeech, settings.ttsEnabled, chat, voice]);

  // Actions
  const startRecording = useCallback(async () => {
    if (isBusy) return;
    
    try {
      await voice.startRecording();
    } catch (error) {
      console.error('Failed to start recording:', error);
      toast.error('Failed to start recording');
    }
  }, [isBusy, voice]);

  const stopRecording = useCallback(async () => {
    // Optimistic UI: Show placeholder immediately
    const optimisticId = logEntries.addOptimisticEntry();

    try {
      const text = await voice.stopRecording();
      
      // Remove optimistic entry
      logEntries.removeOptimisticEntry(optimisticId);
      
      if (!text.trim()) {
        toast.error('No speech detected');
        return;
      }
      await processResponse(text);
    } catch {
      // Remove optimistic entry on error
      logEntries.removeOptimisticEntry(optimisticId);
      toast.error('Failed to process recording');
    }
  }, [voice, logEntries, processResponse]);

  const submitText = useCallback(async (text: string) => {
    await processResponse(text);
  }, [processResponse]);

  const replayQuestion = useCallback(() => {
    if (!settings.ttsEnabled) {
      toast.error('Text-to-speech is disabled');
      return;
    }
    if (logEntries.currentQuestion && !voice.isSpeaking) {
      voice.speak(logEntries.currentQuestion).catch(console.error);
    }
  }, [logEntries.currentQuestion, voice, settings.ttsEnabled]);

  const startNewSession = useCallback(async () => {
    try {
      await logEntries.startNewSession();
      chat.resetConversation();
      phaseTracking.reset();
      setAnalysisDepth(null); // Reset depth for new session
      
      toast.success('New session started');

      if (settings.autoplaySpeech && settings.ttsEnabled) {
        voice.speak(logEntries.currentQuestion).catch(console.error);
      }
    } catch {
      console.error('Failed to start new session');
    }
  }, [logEntries, chat, phaseTracking, settings.autoplaySpeech, settings.ttsEnabled, voice]);

  // Complete current session and start new one
  const completeAndStartNew = useCallback(async () => {
    try {
      await logEntries.completeCurrentAndStartNew();
      chat.resetConversation();
      phaseTracking.reset();
      setAnalysisDepth(null); // Reset depth for new session
      
      if (settings.autoplaySpeech && settings.ttsEnabled) {
        voice.speak(logEntries.currentQuestion).catch(console.error);
      }
    } catch {
      console.error('Failed to complete and start new session');
    }
  }, [logEntries, chat, phaseTracking, settings.autoplaySpeech, settings.ttsEnabled, voice]);

  const deleteConversation = useCallback(async () => {
    try {
      await logEntries.deleteCurrentSession();
      chat.resetConversation();
      phaseTracking.reset();
      setAnalysisDepth(null); // Reset depth for new session
    } catch {
      console.error('Failed to delete conversation');
    }
  }, [logEntries, chat, phaseTracking]);

  return {
    // State (read-only)
    status,
    isBusy,
    currentQuestion: logEntries.currentQuestion,
    isFirstInteraction: logEntries.isFirstInteraction,
    logEntries: logEntries.logEntries,
    audioLevel: voice.audioLevel,
    currentSessionId: logEntries.currentSessionId,
    phaseProgress: phaseTracking.phaseProgress,
    currentPhase: phaseTracking.currentPhase,
    infoTracker: phaseTracking.infoTracker,
    qualityMetrics: phaseTracking.qualityMetrics,
    lastAssessment: phaseTracking.lastAssessment,
    realtimeTranscriptionText: voice.partialTranscript || realtimeTranscriptText,
    sessions: logEntries.sessions,
    isLoadingSessions: logEntries.isLoadingSessions,
    
    // Analysis depth
    analysisDepth,
    completeness: phaseTracking.completeness,

    // Actions
    startRecording,
    stopRecording,
    submitText,
    replayQuestion,
    startNewSession,
    completeAndStartNew,
    deleteConversation,
    importLogEntries: logEntries.importEntries,
    resumeSession: logEntries.resumeSession,
    archiveSession: logEntries.archiveSession,
    deleteSession: logEntries.deleteSession,
    setAnalysisDepth,

    // Pass-through for Report
    speak: voice.speak,
    stopSpeaking: voice.stopSpeaking,
    isSpeaking: voice.isSpeaking,
  };
}
